<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Mini Pac-Man</title>
  <style>
    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(30, 20px);
      grid-template-rows: repeat(20, 20px);
      gap: 1px;
    }
    .cell {
      width: 20px;
      height: 20px;
      background: #111;
      border-radius: 5px;
    }
    .dot {
      background: yellow;
      border-radius: 50%;
    }
    .player {
      background: #00f;
      border-radius: 50%;
    }
    .wall {
      background: #333;
    }
    .border {
      background: #444;
    }
  </style>
</head>
<body>
  <div id="game"></div>

  <script>
    const game = document.getElementById("game");
    const rows = 20;
    const cols = 30;
    const cells = [];

    let playerX = 1;
    let playerY = 1;

    // Tworzymy tablicę dla mapy
    const level = Array.from({ length: rows }, () => Array(cols).fill(0));

    // Funkcja do generowania ścian (losowo rozmieszczonych)
    function generateWalls() {
      // Dodajemy obramówkę wokół planszy
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) {
            level[y][x] = 3; // Obramówka
          }
        }
      }

      // Losowe dodawanie ścian w środku planszy
      for (let y = 1; y < rows - 1; y++) {
        for (let x = 1; x < cols - 1; x++) {
          if (Math.random() < 0.2) { // Zmniejsz lub zwiększ wartość, aby kontrolować gęstość ścian
            level[y][x] = 1; // Ściana
          }
        }
      }

      // Upewniamy się, że są drogi: zaczynamy od lewego górnego rogu i rozbudowujemy drogę
      const stack = [[1, 1]];
      level[1][1] = 2; // Początek drogi

      while (stack.length > 0) {
        const [cy, cx] = stack.pop();
        const directions = [
          [-1, 0], [1, 0], [0, -1], [0, 1] // góra, dół, lewo, prawo
        ];

        // Sprawdzanie czterech kierunków
        for (let [dy, dx] of directions) {
          const ny = cy + dy;
          const nx = cx + dx;
          if (ny >= 1 && ny < rows - 1 && nx >= 1 && nx < cols - 1 && level[ny][nx] === 0) {
            level[ny][nx] = 2; // Dodajemy drogę
            stack.push([ny, nx]);
          }
        }
      }

      // Dodawanie monet (kropek) w dostępnych miejscach
      for (let y = 1; y < rows - 1; y++) {
        for (let x = 1; x < cols - 1; x++) {
          if (level[y][x] === 0 && Math.random() < 0.1) { // 10% szans na monetę w danej komórce
            level[y][x] = 0; // Dodajemy monetę
          }
        }
      }

      // Sprawdzanie dostępności monet
      checkReachableDots();

      // Tworzymy planszę w DOM
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          if (level[y][x] === 1) {
            cell.classList.add("wall"); // Dodajemy ścianę
          } else if (level[y][x] === 0) {
            cell.classList.add("dot"); // Dodajemy monetę
          } else if (level[y][x] === 2) {
            cell.classList.add("dot"); // Droga
          } else if (level[y][x] === 3) {
            cell.classList.add("border"); // Obramówka
          }
          game.appendChild(cell);
          cells.push(cell);
        }
      }
    }

    function checkReachableDots() {
      // Sprawdzamy, które komórki są dostępne z pozycji gracza
      const stack = [[playerY, playerX]];
      const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
      visited[playerY][playerX] = true;

      const directions = [
        [-1, 0], [1, 0], [0, -1], [0, 1] // góra, dół, lewo, prawo
      ];

      while (stack.length > 0) {
        const [cy, cx] = stack.pop();

        for (let [dy, dx] of directions) {
          const ny = cy + dy;
          const nx = cx + dx;

          if (ny >= 1 && ny < rows - 1 && nx >= 1 && nx < cols - 1 && !visited[ny][nx] && level[ny][nx] !== 1 && level[ny][nx] !== 3) {
            visited[ny][nx] = true;
            stack.push([ny, nx]);
          }
        }
      }

      // Zamieniamy wszystkie niedostępne monety na ściany
      for (let y = 1; y < rows - 1; y++) {
        for (let x = 1; x < cols - 1; x++) {
          if (level[y][x] === 0 && !visited[y][x]) {
            level[y][x] = 1; // Zamieniamy monetę na ścianę
          }
        }
      }
    }

    function getIndex(x, y) {
      return y * cols + x;
    }

    function draw() {
      cells.forEach(c => {
        c.classList.remove("player");
      });
      cells[getIndex(playerX, playerY)].classList.add("player");
      cells[getIndex(playerX, playerY)].classList.remove("dot");
    }

    generateWalls();
    draw();

    document.addEventListener("keydown", (e) => {
      // Poruszanie graczem z uwzględnieniem ścian
      if (e.key === "ArrowRight" && playerX < cols - 2 && level[playerY][playerX + 1] !== 1 && level[playerY][playerX + 1] !== 3) playerX++;
      if (e.key === "ArrowLeft" && playerX > 1 && level[playerY][playerX - 1] !== 1 && level[playerY][playerX - 1] !== 3) playerX--;
      if (e.key === "ArrowUp" && playerY > 1 && level[playerY - 1][playerX] !== 1 && level[playerY - 1][playerX] !== 3) playerY--;
      if (e.key === "ArrowDown" && playerY < rows - 2 && level[playerY + 1][playerX] !== 1 && level[playerY + 1][playerX] !== 3) playerY++;
      draw();
    });
  </script>
</body>
</html>
